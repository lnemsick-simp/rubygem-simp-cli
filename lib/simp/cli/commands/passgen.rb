require 'simp/cli/commands/command'
require 'highline/import'

class Simp::Cli::Commands::Passgen < Simp::Cli::Commands::Command
  require 'fileutils'

  DEFAULT_ENVIRONMENT = 'production'

  def initialize
    @operation = nil
    @environment = nil
    @backend = nil
    @folder = nil        # passgen sub-folder in libkv
    @password_dir = nil  # fully qualified path to legacy passgen dir
    @names = Array.new
    @auto_gen_passwords = true
    @password_length = nil
    @password_complexity = nil
    @password_complex_only = nil
    @force_remove = false
  end

  #####################################################
  # Simp::Cli::Commands::Command API methods
  #####################################################
  #
  def description
    "Utility for managing 'simplib::passgen' passwords"
  end

  def help
    parse_command_line( [ '--help' ] )
  end

  def run(args)
    parse_command_line(args)
    return if @help_requested

    @environment = (@environment.nil? ? DEFAULT_ENVIRONMENT : @environment)

    manager = nil
    keydir = nil
    if legacy_passgen?
      manager = Simp::Cli::Passgen::LegacyPasswordManager.new(@environment)
      keydir = @password_dir
    else
      manager = Simp::Cli::Passgen::PasswordManager.new(@environment,
        @backend)
      keydir = @folder
    end

    case @operation
    when :show_environment_list
      show_environment_list
    when :show_name_list
      manager.show_name_list(keydir)
    when :show_passwords
      manager.show_passwords(keydir)
    when :set_passwords
      manager.set_passwords(keydir, @names)
    when :remove_passwords
      manager.remove_passwords(keydir, @names)
    end
  end

  #####################################################
  # Custom methods
  #####################################################



  def legacy_passgen?
    # check which version of passgen is being used by the environment
    true
  end

  def parse_command_line(args)
    raise OptionParser::ParseError.new('The SIMP Passgen Tool requires at least one option') if args.empty?

    opt_parser = OptionParser.new do |opts|
      opts.banner = "\n=== The SIMP Passgen Tool ===."
      opts.separator ''
      opts.separator 'The SIMP Passgen Tool is a simple password control utility. It allows the'
      opts.separator 'viewing, setting, and removal of passwords generated by simplib::passgen.'
      opts.separator ''
      opts.separator '  # show a list of environments that may have simp::passgen passwords'
      opts.separator '  simp passgen -E'
      opts.separator ''
      opts.separator '  # show a list of the password names for the production environment'
      opts.separator '  simp passgen -l'
      opts.separator ''
      opts.separator '  # show the passwords for a list of names for the dev environment'
      opts.separator '  simp passgen -e dev -n NAME1,NAME2,NAME3'
      opts.separator ''
      opts.separator '  # show the passwords for the given list of names for the dev environment'
      opts.separator '  simp passgen [-e ENV] [--backend] [--force-remove] -r NAME1,...'
      opts.separator '  simp passgen [-e ENV] [--backend] [--[no]-auto-generate] \\'
      opts.separator '    [--complexity COMPLEXITY] [--[no-]complex_only] \\',
      opts.separator '    [--length LENGTH] -s NAME1,...'
      opts.separator ''
      opts.separator "COMMANDS:\n"

      opts.on('-E', '--list-env', 'List possible environments that may contain passwords.') do
        @operation = :show_environment_list
      end

#FIXME since not recursively listing, may need to specify an optional folder for libkv
      opts.on('-l', '--list-name',
        'List possible password names for the specified environment.',
        'For libkv-enabled simplib::passgen, the listing is for the',
        'sub-folder specified by --folder.') do
        @operation = :show_name_list
      end


      opts.on('-n', '--name NAME1[,NAME2,...]', Array,
            'Show password(s) for NAME1[,NAME2,...] in the',
            'specified environment.',
             'For libkv-enabled simplib::passgen, the listing is for the',
             'sub-folder specified by --folder.') do |names|
        @operation = :show_passwords
        @names = names
      end

# Do we want an option to remove a tree?
      opts.on('-r', '--remove NAME1[,NAME2,...]', Array,
            'Remove all passwords for NAME1[,NAME2,...] in the',
            'specified environment.',
             'For libkv-enabled simplib::passgen, the listing is for the',
             'sub-folder specified by --folder.') do |names|
        @operation = :remove_passwords
        @names = names
      end

      opts.on('-s', '--set NAME1[,NAME2,...]', Array,
            'Set password(s) for NAME1[,NAME2,...] in the',
            'specified environment.',
             'For libkv-enabled simplib::passgen, the listing is for the',
             'sub-folder specified by --folder.') do |names|
        @operation = :set_passwords
        @names = names
      end

      opts.on('-h', '--help', 'Print this message.') do
        puts opts
        @help_requested = true
      end

      opts.separator ''
      opts.separator "COMMAND MODIFIERS:\n"

      opts.on('--backend BACKEND',
            'Specific libkv backend to query for the specified environment.',
            "Defaults to the default backend for simplib::passgen.",
            'Only required if an application uses custom libkv settings in simplib::passgen'.) do |backend|
        @backend = backend
      end

      opts.on('-d', '--dir DIR',
            'Legacy simplib::passgen only.',
            'Fully qualified path to a legacy password store.',
            "Overrides an environment specified by the '-e' option.") do |dir|
        @password_dir = dir
      end

      opts.on('-e', '--env ENV',
            'Puppet environment to which the passgen operation will',
            "be applied. Defaults to '#{DEFAULT_ENVIRONMENT}'.") do |env|
        @environment = env
      end

      opts.on('--folder FOLDER',
        '(Sub-)folder in which to look for password keys in libkv.',
        'For example, to manage for a simplib::passgen identifier of',
        ' "app1/key1", set this to "app1".',
        'Defaults to the top-level folder for passgen.'  ) do |folder|
        @folder = folder
      end

      opts.on('--[no-]auto-generate', Boolean,
            'Whether to auto-generate new passwords.',
            'When false the user will be prompted to enter new passwords.',
            'Defaults to true.') do |auto_gen|
        @auto_gen_passwords = auto_gen
      end

      opts.on('--complexity', Integer,
            'Password complexity to use when auto-generated.',
            'For existing passwords stored in libkv, defaults to the current password complexity.',
            "Otherwise, defaults to '0'.",
            'See simplib::passgen documentation for details'.) do |complexity|
        @password_complexity = complexity
      end

      opts.on('--[no-]complex-only', Boolean,
            'Whether to only use only complex characters when password is auto-generated.',
            'For existing passwords stored in libkv, defaults to the current password setting.',
            "Otherwise, defaults to 'false'.",
            'See simplib::passgen documentation for details'.) do |complex_only|
        @password_complex_only = complex_only
      end

      opts.on('--length', Integer,
            'Password length to use when auto-generated.',
            'Defaults to the current password length.') do |length|
        @password_length = length
      end

      opts.on('-f', '--force-remove',
            'Remove passwords without prompting user to verify.',
            'If unspecified, user will be prompted to verify',
            'removal action.') do |force_remove|
        @force_remove = force_remove
      end
    end

    opt_parser.parse!(args)

    unless @help_requested
      if @operation.nil?
        raise OptionParser::ParseError.new("No password operation specified.\n" + opt_parser.help)
      end
    end
  end

  def get_names
    names = []
    begin
      Dir.chdir(@password_dir) do
        names = Dir.glob('*').select do |x|
          File.file?(x) && (x !~ /\.salt$|\.last$/)  # exclude salt and backup files
        end
      end
    rescue SystemCallError => err
      err_msg = "Error occurred while accessing '#{@password_dir}': #{err}"
      raise Simp::Cli::ProcessingError.new(err_msg)
    end
    names.sort
  end

  def get_password(allow_autogenerate = true, attempts = 5)
    if (attempts == 0)
      raise Simp::Cli::ProcessingError.new('FATAL: Too may failed attempts to enter password')
    end

    password = ''
    if allow_autogenerate and yes_or_no('Do you want to autogenerate the password?', true )
      password = Simp::Cli::Utils.generate_password
      puts "  Password set to '#{password}'"
    else
      question1 = "> #{'Enter password'.bold}: "
      password = ask(question1) do |q|
        q.echo = '*'
        q.validate = lambda { |answer| validate_password(answer) }
        q.responses[:not_valid] = nil
        q.responses[:ask_on_error] = :question
        q
      end

      question2 = "> #{'Confirm password'.bold}: "
      confirm_password = ask(question2) do |q|
        q.echo = '*'
        q
      end

      if password != confirm_password
        $stderr.puts '  Passwords do not match! Please try again.'.red.bold

        # start all over, skipping the autogenerate question
        password = get_password(false, attempts - 1)
      end
    end
    password
  end

  def validate_names
    names = get_names
    @names.each do |name|
      unless names.include?(name)
        #FIXME print out names nicely (e.g., max 8 per line)
        raise OptionParser::ParseError.new("Invalid name '#{name}' selected.\n\nValid names: #{names.join(', ')}")
      end
    end
  end

  def validate_password(password)
    begin
      Simp::Cli::Utils::validate_password(password)
      return true
    rescue Simp::Cli::PasswordError => e
      $stderr.puts "  #{e.message}.".red.bold
      return false
    end
  end

  def validate_password_dir
    unless File.exist?(@password_dir)
      err_msg = "Password directory '#{@password_dir}' does not exist"
      raise Simp::Cli::ProcessingError.new(err_msg)
    end

    unless File.directory?(@password_dir)
      err_msg = "Password directory '#{@password_dir}' is not a directory"
      raise Simp::Cli::ProcessingError.new(err_msg)
    end
  end

# For listing of environments
# look at /etc/puppetlabs/code/environments for possible environments
# NO OPTION 1
# iterate through each
# - Examine simplib version of the environment selected
#    YES: puppet module list --tree | grep simplib
#    │ └─┬ simp-simplib (v3.17.0)
# - If has newer simplib, can do all operations on new or old passwords
#   using manifests for new simplib::passgen::xxx commands
# - If does not have newer simplib, there won't be any libkv passwords.  So,
#   execute the legacy 'simp passgen' code.
#
# environment_exists
#   directory exists and is not empty
#
# YES OPTION 2
# iterate through each
# remove environments that don't have simp-simplib
#
  def show_environment_list
# return the environments that have passgen keys
# which backend? --> default backend unless specified
# otherwise.  Will need to read  libkv::options in case
# has a backend hard-coded in lieu of 'default'.  May
# be auto_default as well.
#
#   will have to query both old and new and merge
# simplib::passgen::environments
#FIXME Only way to replace is with a directory list of environments dir...
#May want to go further and check if has modules.
    # FIXME This ASSUMES @password_dir follows a known pattern of
    #   <env dir>/<env>/simp_autofiles/gen_passwd
    # (which also assumes Linux path separators)
    result = execute_apply(manifest, nil)

    puts "Environments:\n\t#{environments.join("\n\t")}"
    puts
  end

# For all other commands (show_name_list, show_passwords, etc.)
# - Examine simplib version of the environment selected
#    YES: puppet module list --tree | grep simplib
#    │ └─┬ simp-simplib (v3.17.0)
# - If has newer simplib, can do all operations on new and old passwords
#   using manifests for new simplib::passgen::xxx commands
# - If does not have newer simplib, there won't be any libkv passwords.  So,
#   execute the legacy 'simp passgen' code.
# 

  def show_name_list
    validate_password_dir
    names = get_names
    puts "#{@environment} Names:\n\t#{names.join("\n\t")}"
    puts
  end

  def show_passwords
    validate_password_dir
    validate_names

    title =  "#{@environment} Environment"
    puts title
    puts '='*title.length
    @names.each do |name|
      Dir.chdir(@password_dir) do
        puts "Name: #{name}"
        current_password = File.open("#{@password_dir}/#{name}", 'r').gets
        puts "  Current:  #{current_password}"
        last_password = nil
        last_password_file = "#{@password_dir}/#{name}.last"
        if File.exists?(last_password_file)
          last_password = File.open(last_password_file, 'r').gets
        end
        puts "  Previous: #{last_password}" if last_password
      end
      puts
    end
  end

  def backup_password_files(password_filename)
    backup_passwords = @backup_passwords
    if backup_passwords.nil?
      backup_passwords = yes_or_no("Would you like to rotate the old password?", false)
    end
    if backup_passwords
      begin
        FileUtils.mv(password_filename, password_filename + '.last', :verbose => true, :force => true)
        salt_filename = password_filename + '.salt'
        if File.exists?(salt_filename)
          FileUtils.mv(salt_filename, salt_filename + '.last', :verbose => true, :force => true)
        end
      rescue SystemCallError => err
        err_msg = "Error occurred while backing up '#{password_filename}' files: #{err}"
        raise Simp::Cli::ProcessingError.new(err_msg)
      end
    end
  end

# OLD PASSGEN
# need to use simplib::gen_random_password to generate new password and salt
# FileUtils.cp with preserve to backup last files to dot files
# then FileUtils.cp with preserve to copy current contents to the last contents
# overwrite current contents
# remove last dot files
# revert if any failure
# NEW PASSGEN
# use the api...
  def set_passwords
    validate_password_dir
    @names.each do |name|
      next if name.strip.empty?
      password_filename = "#{@password_dir}/#{name}"

      puts "#{@environment} Name: #{name}"
      password = get_password
      backup_password_files(password_filename) if File.exists?(password_filename)

      begin
        # Remove any residual salt file, as per best security practices,
        # it should not be used with the new password.  simplib::passgen()
        # (from SIMP's simplib puppet module) will create a new salt file
        # when it is needed.
        FileUtils.rm_f(password_filename + '.salt')

        File.open(password_filename, 'w') { |file| file.puts password }

        # Ensure that the ownership and permissions are correct
        puppet_user = `puppet config print user 2>/dev/null`.strip
        puppet_group = `puppet config print group 2>/dev/null`.strip
        if puppet_user.empty? or puppet_group.empty?
          err_msg = 'Could not set password file ownership:  unable to determine puppet user and group'
          raise Simp::Cli::ProcessingError.new(err_msg)
        end
        FileUtils.chown(puppet_user, puppet_group, password_filename)
        FileUtils.chmod(0640, password_filename)

      rescue ArgumentError => err
        # This will happen if group does not exist
        err_msg = "Could not set password file ownership: #{err}"
        raise Simp::Cli::ProcessingError.new(err_msg)
      rescue SystemCallError => err
        err_msg = "Error occurred while writing '#{password_filename}': #{err}"
        raise Simp::Cli::ProcessingError.new(err_msg)
      end
      puts
    end
  end

  def remove_passwords
    validate_password_dir
    validate_names

    @names.each do |name|
      password_filename = "#{@password_dir}/#{name}"
      if File.exists?(password_filename)
        remove = @force_remove
        unless remove
          remove = yes_or_no("Are you sure you want to remove all entries for #{name}?", false)
        end
        if remove
          File.delete(password_filename)
          puts "#{password_filename} deleted"

          salt_password_filename = password_filename + '.salt'
          if File.exists?(salt_password_filename)
            File.delete(salt_password_filename)
            puts "#{salt_password_filename} deleted"
          end

          last_password_filename = password_filename + '.last'
          if File.exists?(last_password_filename)
            File.delete(last_password_filename)
            puts "#{last_password_filename} deleted"
          end
        end
      end
      puts
    end
  end

  def validate_environment
  end

  def yes_or_no(prompt, default_yes)
    question = "> #{prompt.bold}: "
    answer = ask(question) do |q|
      q.validate = /^y$|^n$|^yes$|^no$/i
      q.default = (default_yes ? 'yes' : 'no')
      q.responses[:not_valid] = "Invalid response. Please enter 'yes' or 'no'".red
      q.responses[:ask_on_error] = :question
      q
    end
    result = (answer.downcase[0] == 'y')
  end
end
